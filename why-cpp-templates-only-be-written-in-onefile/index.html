<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="在一般的 C++ 开发中，习惯将函数声明与实现放在不同的文件中，如声明放在 .h 文件，实现放在 .cpp 文件，并在其它地方引用时只包含 .h 文件。但对于 C++ 的模板，这是一个例外，它只能被写在一个文件中。 普通函数 // test.h int sumInt(int a, int b); //"><meta name=theme-color media="(prefers-color-scheme: light)" content="white"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#0f172a"><meta property="og:title" content="为什么 C++ 模板只能写在一个文件里？"><meta property="og:description" content="在一般的 C++ 开发中，习惯将函数声明与实现放在不同的文件中，如声明放在 .h 文件，实现放在 .cpp 文件，并在其它地方引用时只包含 .h 文件。但对于 C++ 的模板，这是一个例外，它只能被写在一个文件中。 普通函数 // test.h int sumInt(int a, int b); //"><meta property="og:type" content="article"><meta property="og:url" content="https://sxyz.blog/why-cpp-templates-only-be-written-in-onefile/"><meta property="og:image" content="https://sxyz.blog/images/others/artwork.jpg"><meta property="article:section" content><meta property="article:published_time" content="2021-09-29T15:49:30+08:00"><meta property="article:modified_time" content="2021-09-29T15:49:30+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sxyz.blog/images/others/artwork.jpg"><meta name=twitter:title content="为什么 C++ 模板只能写在一个文件里？"><meta name=twitter:description content="在一般的 C++ 开发中，习惯将函数声明与实现放在不同的文件中，如声明放在 .h 文件，实现放在 .cpp 文件，并在其它地方引用时只包含 .h 文件。但对于 C++ 的模板，这是一个例外，它只能被写在一个文件中。 普通函数 // test.h int sumInt(int a, int b); //"><title data-site="Sxyazi’s blog">为什么 C++ 模板只能写在一个文件里？ | Sxyazi’s blog</title><link rel=stylesheet href=/assets/index-fad781fe.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><meta name=theme-color content="#ffffff"></head><body><main><nav id=nav><a href=/>Home</a><a href=/archives/>Archives</a><a href=/tags/>Tags</a><a href=/links/>Links</a><a href=/about/>About</a></nav><section id=post><h1>为什么 C++ 模板只能写在一个文件里？</h1><time datetime=2021-09-29T15:49:30+0800>09-29</time>
<span>why-cpp-templates-only-be-written-in-onefile</span><div><p>在一般的 C++ 开发中，习惯将函数声明与实现放在不同的文件中，如声明放在 <code>.h</code> 文件，实现放在 <code>.cpp</code> 文件，并在其它地方引用时只包含 <code>.h</code> 文件。但对于 C++ 的模板，这是一个例外，它只能被写在一个文件中。<p>普通函数<pre><code class=language-cpp>// test.h
int sumInt(int a, int b);
</code></pre><pre><code class=language-cpp>// test.cpp
int sumInt(int a, int b) {
  return a + b;
}
</code></pre><p>模板函数<pre><code class=language-cpp>// test.cpp
template&lt;typename T&gt;
T sum(T a, T b) {
  return a + b;
}
</code></pre><h2 id=编译阶段>编译阶段</h2><p>要理解为什么这样，需要先了解 C++ 的编译、链接过程。首先要知道的是，每个 <code>.cpp</code> 文件会被独立编译为对应的 <code>.obj</code> 文件，这个文件是 <code>.cpp</code> 文件的二进制汇编版本。<p>但随着模块化设计的发展，可能会出现一个文件调用另一个文件函数的情况，由于独立编译的缘故，这些函数的地址不能被确定，因此生成的 <code>CALL</code> 指令跟随的是一个虚拟函数地址。<h2 id=链接阶段>链接阶段</h2><p>当整个编译过程结束后，开始链接流程。即将所有的 <code>.obj</code> 文件链接为对应操作系统的可执行文件，如 Windows 的 <code>.exe</code> 文件。在这个过程中，真实的函数地址才得以确定。<p>简单来说，编译期间不会检查函数是否实现，它只需要函数的声明。但在链接时，要处理函数间的调用关系，此时才会检查函数的具体实现。<h2 id=模板的困境>模板的困境</h2><p>由于 C++ 的模板原理是根据调用方参数类型，生成多个不同的实现。如<pre><code class=language-cpp>sum(1, 2);
sum(1.0, 2.0);
</code></pre><p>将生成如下两种实现<pre><code class=language-cpp>int sum(int a, int b) { return a + b; }
double sum(double a, double b) { return a + b; }
</code></pre><p>生成操作在编译阶段完成，若模板函数的声明与实现分离，且在其它地方使用时只引用了 <code>.h</code> 文件，则会由于无法找到对应的模板代码，无法生成出不同的实现。<p>由于编译阶段只检查函数有无声明，因此不会产生编译错误。但在链接时，会因无法找到与之匹配的实现而报错。<h2 id=要怎么做>要怎么做</h2><ul><li>将模板函数的声明与实现写在同一个文件里，按照约定可以命名为 <code>.hpp</code> 文件；<li>（不推荐）若写到了不同文件中，则在使用时将全部相关文件一并引入；</ul></div><ul><li><a href=/tags/c++>C++</a></ul></section></main><app></app><noscript>You need to enable JavaScript to run this app.</noscript><script type=module crossorigin src=/assets/index-b1ee8dc4.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XWVTHMXTRH"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XWVTHMXTRH")</script></body></html>