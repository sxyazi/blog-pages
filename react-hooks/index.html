<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="前言 在 React 16.8 中，引入了 Hooks 的概念，它旨在更好的复用“状态逻辑”。React Hooks 的核心思想就是“状态+行为”，其中行为指的是“控制状态的逻辑”。 像人们所熟知的那样，模板代码可以通过组件化的形式复用，而在 Hooks 出现"><meta name=theme-color media="(prefers-color-scheme: light)" content="white"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#0f172a"><meta property="og:title" content="React Hooks 编码模式的变化"><meta property="og:description" content="前言 在 React 16.8 中，引入了 Hooks 的概念，它旨在更好的复用“状态逻辑”。React Hooks 的核心思想就是“状态+行为”，其中行为指的是“控制状态的逻辑”。 像人们所熟知的那样，模板代码可以通过组件化的形式复用，而在 Hooks 出现"><meta property="og:type" content="article"><meta property="og:url" content="https://sxyz.blog/react-hooks/"><meta property="og:image" content="https://sxyz.blog/images/others/artwork.jpg"><meta property="article:section" content><meta property="article:published_time" content="2022-01-09T22:55:13+08:00"><meta property="article:modified_time" content="2022-01-09T22:55:13+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sxyz.blog/images/others/artwork.jpg"><meta name=twitter:title content="React Hooks 编码模式的变化"><meta name=twitter:description content="前言 在 React 16.8 中，引入了 Hooks 的概念，它旨在更好的复用“状态逻辑”。React Hooks 的核心思想就是“状态+行为”，其中行为指的是“控制状态的逻辑”。 像人们所熟知的那样，模板代码可以通过组件化的形式复用，而在 Hooks 出现"><title data-site="Sxyazi’s blog">React Hooks 编码模式的变化 | Sxyazi’s blog</title><link rel=stylesheet href=/assets/index-fad781fe.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><meta name=theme-color content="#ffffff"></head><body><main><nav id=nav><a href=/>Home</a><a href=/archives/>Archives</a><a href=/tags/>Tags</a><a href=/links/>Links</a><a href=/about/>About</a></nav><section id=post><h1>React Hooks 编码模式的变化</h1><time datetime=2022-01-09T22:55:13+0800>01-09</time>
<span>react-hooks</span><div><h2 id=前言>前言</h2><p>在 React 16.8 中，引入了 Hooks 的概念，它旨在更好的复用“状态逻辑”。React Hooks 的核心思想就是“状态+行为”，其中行为指的是“控制状态的逻辑”。<p>像人们所熟知的那样，模板代码可以通过组件化的形式复用，而在 Hooks 出现前，“状态逻辑”的复用是让人们及其头疼的问题之一，通常情况下，只能有限的复用“逻辑代码”（即只包含行为而没有与之相关的状态），状态则被耦合在了模板中，Hooks 的出现解决了这个问题。<h3 id=术语解释>术语解释</h3><ul><li>属性（Property）：不变的数据；<li>状态（State）：变化的数据，一定包含改变状态的“行为”；<li>行为（Behavior）：改变状态的逻辑；<li>作用（Effect）：作用于视图，是行为的一种，但与状态无关，如 DOM 操作、页面跳转；</ul><h2 id=例子>例子</h2><p>有一个同步器 Syncer 组件，它将处理传入的 <code>tasks</code> 任务，并在全部任务完成时，将 <code>tasks</code> 清空，然后继续等待下次任务。使用最简单的方式将它实现：<pre><code class=language-jsx>import React, { useEffect, useState } from 'react'

function Syncer({ tasks, onSuccess }) {
	useEffect(() =&gt; {
		if (tasks.length === 0) {
			return
		}

		for (const task of tasks) {
			// handle tasks...
		}

		// 假设300ms处理完成，仅供演示，这里应该是同步的
		setTimeout(onSuccess, 300)
	}, [tasks])

	return &lt;div&gt;{tasks.length ? 'Syncing...' : 'No tasks'}&lt;/div&gt;
}

export default function App() {
	const [tasks, setTasks] = useState([])
	const getTasks = () =&gt; [Math.random(), Math.random()]

	return (
		&lt;&gt;
			&lt;button onClick={() =&gt; setTasks((tasks) =&gt; [...tasks, ...getTasks()])}&gt;Add tasks&lt;/button&gt;
			&lt;Syncer tasks={tasks} onSuccess={() =&gt; setTasks([])} /&gt;
		&lt;/&gt;
	)
}
</code></pre><p>上面的代码运行的很好，但有个问题：<code>tasks</code> 状态被放在了父组件，<code>Syncer</code> 组件就仅仅实现了对“逻辑代码”的复用，状态部分的代码没有得到复用。<h3 id=改进使用引用>改进：使用引用</h3><p>React 提供了对组件的引用支持，可以通过引用，在外部访问组件内所暴露的方法。这里使用 <code>useImperativeHandle</code> 向外暴露了 <code>addTasks</code> 方法，它被用于向任务队列中添加新的任务。<pre><code class=language-jsx>import React, { forwardRef, useEffect, useImperativeHandle, useRef, useState } from 'react'

const Syncer = forwardRef((props, ref) =&gt; {
	const [tasks, setTasks] = useState([])

	useImperativeHandle(ref, () =&gt; ({
		addTasks: (newTasks) =&gt; setTasks((tasks) =&gt; [...tasks, ...newTasks]),
	}))

	useEffect(() =&gt; {
		if (tasks.length === 0) {
			return
		}

		for (const task of tasks) {
			// handle tasks...
		}

		// 假设300ms处理完成，仅供演示，这里应该是同步的
		setTimeout(() =&gt; setTasks([]), 300)
	}, [tasks])

	return &lt;div&gt;{tasks.length ? 'Syncing...' : 'No tasks'}&lt;/div&gt;
})

export default function App() {
	const refSyncer = useRef()
	const getTasks = () =&gt; [Math.random(), Math.random()]

	return (
		&lt;&gt;
			&lt;button onClick={() =&gt; refSyncer.current.addTasks(getTasks())}&gt;Add task&lt;/button&gt;
			&lt;Syncer ref={refSyncer} /&gt;
		&lt;/&gt;
	)
}
</code></pre><p>需要注意的是，代码中的状态 <code>tasks</code> 被移动到了 <code>Syncer</code> 组件内，这实现了对状态的复用，但这种方式不太直观，容易让人产生误解。<h3 id=改进使用自定义-hook>改进：使用自定义 Hook</h3><p>React 鼓励人们封装特定于某类业务的 Hook 函数，当然 GitHub 上也有很多开源的 Hooks。下面代码使用自定义 Hook 的方式实现了相同的逻辑，在代码量减小的同时，易读性得到了提升。<pre><code class=language-jsx>import React, { useEffect, useState } from 'react'

function useSyncer(initialTasks) {
	const [tasks, setTasks] = useState(initialTasks)

	useEffect(() =&gt; {
		if (tasks.length === 0) {
			return
		}

		for (const task of tasks) {
			// handle tasks...
		}

		// 假设300ms处理完成，仅供演示，这里应该是同步的
		setTimeout(() =&gt; setTasks([]), 300)
	}, [tasks])

	return {
		Syncer: () =&gt; &lt;div&gt;{tasks.length ? 'Syncing...' : 'No tasks'}&lt;/div&gt;,
		addTasks: (newTasks) =&gt; setTasks((tasks) =&gt; [...tasks, ...newTasks]),
	}
}

export default function App() {
	const { Syncer, addTasks } = useSyncer([])
	const getTasks = () =&gt; [Math.random(), Math.random()]

	return (
		&lt;&gt;
			&lt;button onClick={() =&gt; addTasks(getTasks())}&gt;Add task&lt;/button&gt;
			&lt;Syncer /&gt;
		&lt;/&gt;
	)
}
</code></pre><h2 id=总结>总结</h2><p>再次回想 React Hooks 的核心思想：<ul><li>关键字：组合、解耦；<li>与 UI 解耦，UI 不管逻辑是什么，只管渲染；<li>UI 中可以嵌入各种各样的 Hooks（逻辑在 Hooks 中）；</ul></div><ul><li><a href=/tags/react>React</a></ul></section></main><app></app><noscript>You need to enable JavaScript to run this app.</noscript><script type=module crossorigin src=/assets/index-b1ee8dc4.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XWVTHMXTRH"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XWVTHMXTRH")</script></body></html>