<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sxyazi’s blog</title><link>https://sxyz.blog/</link><description>Recent content on Sxyazi’s blog</description><language>zh-CN</language><lastBuildDate>Mon, 15 May 2023 23:25:15 +0800</lastBuildDate><atom:link href="https://sxyz.blog/index.xml" rel="self" type="application/rss+xml"/><item><title>我为什么换到了 Tab 缩进</title><link>https://sxyz.blog/why-i-use-tab-for-indent/</link><pubDate>Wed, 05 Jul 2023 21:04:38 +0800</pubDate><guid>https://sxyz.blog/why-i-use-tab-for-indent/</guid><description>曾经，我是 Space 的忠实粉丝，写 JavaScript 时，我用 2-space 缩进；写 Python/Rust 时，我用 4-space 缩进；写 Go 时，我用…… 好吧，它只能用 Tab。 直到去年，看到 Jake Archibald 推文，我又开始重新思考缩进的本质，并从 Space 过渡到了 Tab： Tab 本身就是专门缩进的字符</description></item><item><title>Neovim 异步格式化探索</title><link>https://sxyz.blog/nvim-async-formatting/</link><pubDate>Mon, 15 May 2023 23:25:15 +0800</pubDate><guid>https://sxyz.blog/nvim-async-formatting/</guid><description>很长时间以来，我都在以同步的方式格式化代码，而这么做的唯一原因就是实现简单，我只需要在文件保存前的 BufWritePre 事件中以阻塞的方式调用 vim.lsp.buf.format() 即可轻松完成，就像这样： vim.api.nvim_create_autocmd(&amp;quot;BufWritePre&amp;quot;, { group = group, buffer = bufnr, callback = function() vim.lsp.buf.format { bufnr = bufnr } end }) 但它有个致命问</description></item><item><title>绕过 Cloudflare 指纹护盾</title><link>https://sxyz.blog/bypass-cloudflare-shield/</link><pubDate>Sat, 22 Apr 2023 21:54:44 +0800</pubDate><guid>https://sxyz.blog/bypass-cloudflare-shield/</guid><description>最近才知道，除了 TLS 指纹，竟然还有 HTTP/2 指纹，这两种 Cloudflare 都有采用，这篇博客介绍如何绕过它们。 起因 最近发现之前写的搜图 Bot 坏掉了，这个 Bot 接入了 3 个搜索后端，出问题的是 ascii2d.net。由于它最近套上了 Clo</description></item><item><title>我的 macOS 配置</title><link>https://sxyz.blog/macos-setup/</link><pubDate>Thu, 08 Dec 2022 20:26:42 +0800</pubDate><guid>https://sxyz.blog/macos-setup/</guid><description>这篇文章记录下，一个新的 macOS 需要做的配置，和安装的软件。 键盘布局 使用 Colemak 键盘布局，它比传统 QWERTY 更高效、合理。 在 System Settings - Keyboard - Input Sources - Edit… 中添加 Colemak 以替换 ABC，重新登入系统布局生效。 系统设置 # Auto hide the menubar defaults write -g _HIHideMenuBar</description></item><item><title>图解 Functor、Applicative、Monad</title><link>https://sxyz.blog/functors-applicatives-and-monads-in-pictures/</link><pubDate>Thu, 10 Nov 2022 17:34:32 +0800</pubDate><guid>https://sxyz.blog/functors-applicatives-and-monads-in-pictures/</guid><description>序言 这篇文章是对原文 Functors, Applicatives, And Monads In Pictures 的翻译，由 Aditya Bhargava 撰写，翻译时已取得作者授权。 它是了解函数式编程非常棒的一篇文章，但它的两篇中文译文已不再可用（404、全部图片丢失），另外仅剩的一篇却是以 Kotlin 为导向的，因此</description></item><item><title>从零实现 AES 加密算法</title><link>https://sxyz.blog/aes-from-scratch/</link><pubDate>Fri, 14 Oct 2022 12:07:22 +0800</pubDate><guid>https://sxyz.blog/aes-from-scratch/</guid><description>介绍 AES（Advanced Encryption Standard）是由 NIST（National Institute of Standards and Technology，美国国家标准局）于 2001 年制定的“对称加密算法”，目的是为了取代当时已不安全的 DES 算法。它是 Rijndael 算法</description></item><item><title>让 Hugo 用上 React</title><link>https://sxyz.blog/using-hugo-with-react/</link><pubDate>Thu, 01 Sep 2022 21:17:12 +0800</pubDate><guid>https://sxyz.blog/using-hugo-with-react/</guid><description>最近把博客主题又双叒叕重写了一遍，嘛，生命不息，折腾不止。依然基于 Hugo，但这次把 React 缝合进去了，使用 Vite 构建前端，Tailwind CSS 编写样式，这篇博客记录下整个折腾过程。 新主题在这 https://github.com/sxyazi/hugo-theme-lavias 数据源 由于 Hugo 是一个</description></item><item><title>Golang 并发缓存实践</title><link>https://sxyz.blog/go-concurrent-cache/</link><pubDate>Tue, 30 Aug 2022 22:37:16 +0800</pubDate><guid>https://sxyz.blog/go-concurrent-cache/</guid><description>并发缓存，顾名思义就是让缓存可以在多个并发的 goroutine 中共享、交错使用，这在爬虫程序中尤其常见，每个新的爬虫任务都希望能够“实时地”复用之前，或正在进行中的任务结果，从而避免重复的网络请求开销。 这篇文章，以 yande.re</description></item><item><title>React Hooks 编码模式的变化</title><link>https://sxyz.blog/react-hooks/</link><pubDate>Sun, 09 Jan 2022 22:55:13 +0800</pubDate><guid>https://sxyz.blog/react-hooks/</guid><description>前言 在 React 16.8 中，引入了 Hooks 的概念，它旨在更好的复用“状态逻辑”。React Hooks 的核心思想就是“状态+行为”，其中行为指的是“控制状态的逻辑”。 像人们所熟知的那样，模板代码可以通过组件化的形式复用，而在 Hooks 出现</description></item><item><title>C++ 引用与 const</title><link>https://sxyz.blog/cpp-reference-with-const/</link><pubDate>Mon, 22 Nov 2021 21:19:15 +0800</pubDate><guid>https://sxyz.blog/cpp-reference-with-const/</guid><description>基本概念 引用的本质就是指针，下面两行代码的底层逻辑是一致的 int *p = &amp;amp;a int &amp;amp;ref = a 如果添加 const 限制词，表示不能通过 *p 或 ref 间接修改 a 的值 const int *p = &amp;amp;a const int &amp;amp;ref = a // 等价于 int const *p = &amp;amp;a int const &amp;amp;ref = a 一般常用于参数声明，如 void foo(const int</description></item><item><title>为什么 C++ 模板只能写在一个文件里？</title><link>https://sxyz.blog/why-cpp-templates-only-be-written-in-onefile/</link><pubDate>Wed, 29 Sep 2021 15:49:30 +0800</pubDate><guid>https://sxyz.blog/why-cpp-templates-only-be-written-in-onefile/</guid><description>在一般的 C++ 开发中，习惯将函数声明与实现放在不同的文件中，如声明放在 .h 文件，实现放在 .cpp 文件，并在其它地方引用时只包含 .h 文件。但对于 C++ 的模板，这是一个例外，它只能被写在一个文件中。 普通函数 // test.h int sumInt(int a, int b); //</description></item><item><title>Mac mini with Apple Silicon 使用体验</title><link>https://sxyz.blog/mac-mini-with-apple-silicon/</link><pubDate>Sun, 13 Dec 2020 18:00:32 +0800</pubDate><guid>https://sxyz.blog/mac-mini-with-apple-silicon/</guid><description>我的 Mac mini 是从官网订购的，因为当时其它平台只有 8GB 版本，而作为开发机并且考虑到 macOS 的内存管理机制果断买了 16GB。也正是因此等了近半个月才拿到机器。硬盘选择的是 512G，不过对于我来说开发机 256G 是完全够用的，</description></item><item><title>HomePod 打造音乐闹钟</title><link>https://sxyz.blog/homepod-music-alarm/</link><pubDate>Sun, 09 Aug 2020 20:04:12 +0800</pubDate><guid>https://sxyz.blog/homepod-music-alarm/</guid><description>前言 众所周知，一只独立的 HomePod 只能播放 Apple Music 里面的音乐，并不支持其它 App。如果想用手机或其它设备往上面投歌，它不支持蓝牙，就只能使用基于 Wi-Fi 协议的 AirPlay，这意味着你需要有一台 iPhone 或 Mac 设备，并且忍受它 3</description></item><item><title>使用 GitHub Actions 实现博客自动化部署</title><link>https://sxyz.blog/blog-deploy/</link><pubDate>Sun, 26 Jul 2020 21:12:16 +0800</pubDate><guid>https://sxyz.blog/blog-deploy/</guid><description>TL;DR 最近把博客渲染、部署的工作从我很久前自己写的 blog-deploy 迁移到了 Hugo，原因是前者功能太简单了，而又无心再去维护。顺便又优化了下博客样式，加入了近年来流行的暗色元素。 由于我的博客是全权托管在 GitHub 上的，以前 repo 全</description></item><item><title>使用 PHP 的 Phar 包实现程序自动更新</title><link>https://sxyz.blog/phar-updater/</link><pubDate>Mon, 02 Apr 2018 01:30:03 +0800</pubDate><guid>https://sxyz.blog/phar-updater/</guid><description>前两天有 PHP 的道友问我如何拿 PHP 实现程序自动更新。但是我对自动更新这个功能，说实话是并没有太大兴趣去搞的。我认为我把我写的程序源码放到 GitHub 这种代码托管平台上，然后如果你需要用的话就直接 clone 下来丢到服务器上跑就</description></item><item><title>在 JavaScript 中使用 Generator 函数实现异步变同步操作</title><link>https://sxyz.blog/generator-async-implement/</link><pubDate>Thu, 29 Mar 2018 02:41:26 +0800</pubDate><guid>https://sxyz.blog/generator-async-implement/</guid><description>在 ES6 中提供了一种新的异步编程解决方案，那就是 Generator 函数。这种函数又被称为生成器函数、可暂停函数。在它的方法体内可以使用 yield 关键字，配合 yield 可以实现协程。 本文主要介绍对 Generator 函数的实际应用，不过多介绍 Generator 函数的相关基</description></item><item><title>让 Vue-cli 支持 Netlify 的 Redirect</title><link>https://sxyz.blog/vue-netlify-adaptation/</link><pubDate>Thu, 02 Nov 2017 19:37:15 +0800</pubDate><guid>https://sxyz.blog/vue-netlify-adaptation/</guid><description>最近有个 Vue 项目，是使用 Vue-cli 构建起来的。Vue-Router 是使用的 HTML5 History 模式。这个模式是使用浏览器提供的 History 接口实现的，所以如果是在页面上通过点击链接往里面 push 一个新地址是没问题的，但是如果直接请求这个地址则</description></item><item><title>Golang 协程与通道</title><link>https://sxyz.blog/goroutine-and-channel/</link><pubDate>Sun, 24 Sep 2017 14:33:22 +0800</pubDate><guid>https://sxyz.blog/goroutine-and-channel/</guid><description>这篇文章记录了我学习 Go 语言中的协程与通道的一些笔记，是片断性的。 01. 无缓冲通道 ch := make(chan int) 无缓冲通道只能包含 1 个元素，读和写都是阻塞的。 02. 缓冲通道 ch := make(chan int, 5) 有缓冲的通道可以包含指定个数的元素，读和写都是异步</description></item><item><title>Golang 项目目录结构</title><link>https://sxyz.blog/gopath/</link><pubDate>Sat, 16 Sep 2017 17:02:53 +0800</pubDate><guid>https://sxyz.blog/gopath/</guid><description>项目的目录结构会影响整个项目的文件排布甚至是整个项目的文件架构。所以在开始编写代码之前要先明确项目的目录如何去安排。其它语言可能对项目结构没有什么要求，相对更加自由一些，而 Go 语言做了这方面的规定。这样</description></item><item><title>Golang 指针的一些零散笔记</title><link>https://sxyz.blog/golang-cheatsheet/</link><pubDate>Tue, 12 Sep 2017 18:12:21 +0800</pubDate><guid>https://sxyz.blog/golang-cheatsheet/</guid><description>最近学习了一下 Go 语言，发现里面很多东西都和其他语言都不太一样。下面是学习过程中对 Go 中的指针部分做的一些片段性的笔记。 01. 数组指针 package main import &amp;quot;fmt&amp;quot; func main() { // 一个 [3]int 型数组 arr := [...]int{1, 2, 3} p := &amp;amp;arr // 一个指向 [3]int 型数组的指针 test(p) // 传</description></item><item><title>关系型数据库事务隔离级别</title><link>https://sxyz.blog/db-transaction-isolation/</link><pubDate>Wed, 26 Jul 2017 22:55:10 +0800</pubDate><guid>https://sxyz.blog/db-transaction-isolation/</guid><description>SQL 标准定义了 4 种隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。 低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。 00. 查看隔离级别 # 全局 select @@global.tx_isolation; # 当前会话 select @@session.tx_isolation; # 设</description></item><item><title>为七牛云配置 Let’s Encrypt 证书</title><link>https://sxyz.blog/qiniu-tls/</link><pubDate>Sun, 16 Jul 2017 18:24:19 +0800</pubDate><guid>https://sxyz.blog/qiniu-tls/</guid><description>在上一篇文章《Let’s Encrypt 免费 HTTPS 证书申请》中，介绍了通过 文件验证 的方式申请 Let’s Encrypt 证书，并为 Nginx 配置证书的整个流程。 那么这篇文章来介绍下如何通过 DNS 验证 的方式申请并为 七牛云 配置 SSL 证书。 那么可能会有人说</description></item><item><title>Let’s Encrypt 免费 HTTPS 证书申请</title><link>https://sxyz.blog/lets-encrypt/</link><pubDate>Sun, 09 Jul 2017 23:23:30 +0800</pubDate><guid>https://sxyz.blog/lets-encrypt/</guid><description>我博客使用的是 Let’s Encrypt 的证书，为什么要用他呢？免费啊！而且还很方便，官网上写了这样一句话： Let’s Encrypt is a free, automated, and open Certificate Authority。 之前想整理下申请过程的，可是一直没时间，现在来写一下叭。其实</description></item><item><title>高可用 MongoDB</title><link>https://sxyz.blog/mongo-high-availability/</link><pubDate>Mon, 26 Jun 2017 23:52:15 +0800</pubDate><guid>https://sxyz.blog/mongo-high-availability/</guid><description>MongoDB 是一个基于分布式文件存储的数据库。由 C++语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他</description></item><item><title>Composer 配合 SS 实现依赖加速下载</title><link>https://sxyz.blog/composer-proxy/</link><pubDate>Mon, 05 Jun 2017 20:19:33 +0800</pubDate><guid>https://sxyz.blog/composer-proxy/</guid><description>Composer 在 PHP 开发中绝对算得上是一个利器，现在几乎整天都离不开它了。但是下载依赖安装的过程却非常慢，因为是国外的嘛。这时候可能就需要使用某些手段来加速一下了。这里我使用的是拿 SS 作为一个代理服务器来实现的。（话</description></item><item><title>关系型数据库范式</title><link>https://sxyz.blog/db-normalization/</link><pubDate>Sun, 28 May 2017 00:00:14 +0800</pubDate><guid>https://sxyz.blog/db-normalization/</guid><description>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式</description></item><item><title>使用 Sentinel 完成自动化 Redis 监控</title><link>https://sxyz.blog/redis-sentinel/</link><pubDate>Wed, 24 May 2017 22:33:43 +0800</pubDate><guid>https://sxyz.blog/redis-sentinel/</guid><description>Redis-Sentinel 是 Redis 官方推荐的高可用性(HA) 解决方案，当用 Redis 做 Master-slave 的高可用方案时，假如 master 宕机了，Redis 本身(包括它的很多客户端) 都没有实现自动进行主备切换，而 Redis-sentinel 本身也是一个独立运行的进程，它能监控多个 master-slave 集群，发</description></item><item><title>Redis 主从配置</title><link>https://sxyz.blog/redis-slaves/</link><pubDate>Thu, 11 May 2017 02:34:23 +0800</pubDate><guid>https://sxyz.blog/redis-slaves/</guid><description>前面写了关于 MySQL 主从配置的文章，这篇文章来写一下 Redis 的主从配置。相对于 MySQL 来说简单了很多。 01. 安装 sudo apt-get update sudo apt-get install redis-server mkdir /tmp/redis # 创建测试目录 02. 拷贝两份配置 ha@alh:~/redis $ cp /etc/redis/redis.conf ./redis.master.conf ha@alh:~/redis $ cp /etc/redis/redis.conf ./redis.slave.conf 03. 分别修改配置文件 redis.master.conf: daemonize yes # 守护进程 pidfile /var/run/redis_master.pid # PI</description></item><item><title>MySQL 主从配置</title><link>https://sxyz.blog/mysql-slaves/</link><pubDate>Mon, 08 May 2017 01:45:06 +0800</pubDate><guid>https://sxyz.blog/mysql-slaves/</guid><description>上篇文章，把 MySQL 服务环境搭建好了，这篇文章来写一下 MySQL 主从配置。 01. 修改 MySQL 配置文件 my.master.cnf： [mysqld] log-bin = mysql-bin # 二进制日志文件名 server-id = 1 # 服务器ID expire-logs-days = 7 # (可选) 日志有效期[天] replicate-do-db = test # (可选) 要复</description></item><item><title>Flex 弹性盒模型</title><link>https://sxyz.blog/flex/</link><pubDate>Sun, 30 Apr 2017 02:11:12 +0800</pubDate><guid>https://sxyz.blog/flex/</guid><description>Flex 是一种布局方案。相对于传统的布局方式（浮动 + 定位），Flex 布局具有了「弹性」。这也使得在布局时更加的灵活方便了。 01. 使用 Flex 给一个元素加上 display: flex 即可指定使用 flex 布局。 div { display: flex; } span { /* 内联元素使用 inline-flex */ display: inline-flex; }</description></item><item><title>Linux 文件系统</title><link>https://sxyz.blog/linux-filesystem/</link><pubDate>Tue, 25 Apr 2017 15:14:16 +0800</pubDate><guid>https://sxyz.blog/linux-filesystem/</guid><description>Linux 文件系统中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有 Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。 挂载 在 linux 操作系统中， 挂载是指将一个设备（通常</description></item><item><title>Linux 中文件的隐藏属性与特殊权限</title><link>https://sxyz.blog/linux-chattr/</link><pubDate>Thu, 20 Apr 2017 19:11:35 +0800</pubDate><guid>https://sxyz.blog/linux-chattr/</guid><description>01. 隐藏属性 可以使用 chattr 命令设置文件的隐藏属性，使用命令 lsattr 列出文件的隐藏属性。 chattr chattr [+-=][ASacdistu] 文件或目录名称 选项与参数： + ：添加某一个特殊参数，其他原本存在参数则不动。 - ：移除某一个特殊参数，其他原本存在参数则不动</description></item><item><title>为 Linux 服务器配置 SSH 公钥认证</title><link>https://sxyz.blog/ssh-authentication/</link><pubDate>Tue, 11 Apr 2017 01:00:06 +0800</pubDate><guid>https://sxyz.blog/ssh-authentication/</guid><description>每次连服务器都要输入一遍密码，非常麻烦。所以可以使用 SSH 公钥来解决总要去输密码的痛苦。 其实一般情况下，购买主机在开通服务前可以添加 SSH 公钥的。 01. 创建 ssh-key 如果已经创建过了，那么可以忽略此过程。 $ ssh-keygen -t rsa 之后根据</description></item><item><title>Nginx 配置</title><link>https://sxyz.blog/nginx-config/</link><pubDate>Fri, 07 Apr 2017 05:05:38 +0800</pubDate><guid>https://sxyz.blog/nginx-config/</guid><description>这篇文章写了 Nginx 常见的一些配置选项，整理并记录下来方便以后使用。 01. 目录结构 安装好后的目录结构如下： nginx ├── conf # 配置文件 ├── html # 网站程序 ├── logs # 日志文件 └── sbin # 二进制程序文件 配置文件默认是放在 conf 目录</description></item><item><title>MySQL 无法启动修复</title><link>https://sxyz.blog/mysql-recovery/</link><pubDate>Sun, 26 Mar 2017 01:51:01 +0800</pubDate><guid>https://sxyz.blog/mysql-recovery/</guid><description>报错如下 $ ./mysqld 2017-03-23 08:42:32 1358 [ERROR] InnoDB: Attempted to open a previously opened tablespace. Previous tablespace mysql/slave_relay_log_info uses space ID: 3 at filepath: ./mysql/slave_relay_log_info.ibd. Cannot open tablespace shop/admin which uses space ID: 3 at filepath: ./shop/admin.ibd 2017-03-23 08:42:32 7fffad71c3c0 InnoDB: Operating system error number 2 in a file operation. 修复方式 It means one of your tables is corrupted. Weirdly this has happened to frequently upon a machine crash. This is how I fixed it: open my.cnf (in MAMP &amp;gt; File &amp;gt; Edit Template &amp;gt; MySQL) add the line: innodb_force_recovery = 1 save and</description></item></channel></rss>