<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="序言 这篇文章是对原文 Functors, Applicatives, And Monads In Pictures 的翻译，由 Aditya Bhargava 撰写，翻译时已取得作者授权。 它是了解函数式编程非常棒的一篇文章，但它的两篇中文译文已不再可用（404、全部图片丢失），另外仅剩的一篇却是以 Kotlin 为导向的，因此"><meta name=theme-color media="(prefers-color-scheme: light)" content="white"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#0f172a"><meta property="og:title" content="图解 Functor、Applicative、Monad"><meta property="og:description" content="序言 这篇文章是对原文 Functors, Applicatives, And Monads In Pictures 的翻译，由 Aditya Bhargava 撰写，翻译时已取得作者授权。 它是了解函数式编程非常棒的一篇文章，但它的两篇中文译文已不再可用（404、全部图片丢失），另外仅剩的一篇却是以 Kotlin 为导向的，因此"><meta property="og:type" content="article"><meta property="og:url" content="https://sxyz.blog/functors-applicatives-and-monads-in-pictures/"><meta property="og:image" content="https://sxyz.blog/images/others/artwork.jpg"><meta property="article:section" content><meta property="article:published_time" content="2022-11-10T17:34:32+08:00"><meta property="article:modified_time" content="2022-11-10T17:34:32+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sxyz.blog/images/others/artwork.jpg"><meta name=twitter:title content="图解 Functor、Applicative、Monad"><meta name=twitter:description content="序言 这篇文章是对原文 Functors, Applicatives, And Monads In Pictures 的翻译，由 Aditya Bhargava 撰写，翻译时已取得作者授权。 它是了解函数式编程非常棒的一篇文章，但它的两篇中文译文已不再可用（404、全部图片丢失），另外仅剩的一篇却是以 Kotlin 为导向的，因此"><title data-site="Sxyazi’s blog">图解 Functor、Applicative、Monad | Sxyazi’s blog</title><link rel=stylesheet href=/assets/index-fad781fe.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><meta name=theme-color content="#ffffff"></head><body><main><nav id=nav><a href=/>Home</a><a href=/archives/>Archives</a><a href=/tags/>Tags</a><a href=/links/>Links</a><a href=/about/>About</a></nav><section id=post><h1>图解 Functor、Applicative、Monad</h1><time datetime=2022-11-10T17:34:32+0800>11-10</time>
<span>functors-applicatives-and-monads-in-pictures</span><div><h2 id=序言>序言</h2><p>这篇文章是对原文 <a href=https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html>Functors, Applicatives, And Monads In Pictures</a> 的翻译，由 <a href=https://github.com/egonSchiele>Aditya Bhargava</a> 撰写，翻译时已取得作者授权。<p>它是了解函数式编程非常棒的一篇文章，但它的两篇中文译文已不再可用（404、全部图片丢失），另外仅剩的一篇却是以 Kotlin 为导向的，因此打算自己再翻译一版。<h2 id=正文>正文</h2><p>有一个简单的值：</p><img src=/images/functors/value.png class=bri><p>为其应用一个函数：</p><img src=/images/functors/value_apply.png class=bri><p>这很简单，让我们继续扩展它。我们说，任何一个值都可以放在一个上下文里，你可以认为上下文是一个盒子，然后把值放进去：</p><img src=/images/functors/value_and_context.png class=bri><p>现在，当你将一个函数应用到该值时，你将得到不同的结果 —— 这取决于上下文是什么。这就是 Functors、Applicatives、Monads、Arrows 等存在的基础。有一个 <code>Maybe</code> 数据类型，它定义了两个相关的上下文：</p><img src=/images/functors/context.png class=bri><pre><code class=language-haskell>data Maybe a = Nothing | Just a
</code></pre><p>马上我们就会看到，对 <code>Just a</code> 与 <code>Nothing</code> 应用一个函数，会有什么不同。现在我们先来看看 Functor。<h2 id=functors>Functors</h2><p>当一个值被放在上下文里，你不能对其应用一个普通函数：</p><img src=/images/functors/no_fmap_ouch.png class=bri><p>这时便需要 <code>fmap</code> 出场了，它对上下文了如指掌，知道如何为放在上下文里的值，应用一个函数。比如，你想为 <code>Just 2</code> 应用 <code>(+3)</code>，使用 <code>fmap</code>：<pre><code class=language-haskell>&gt; fmap (+3) (Just 2)
Just 5
</code></pre><img src=/images/functors/fmap_apply.png class=bri><p>很快啊！<code>fmap</code> 就出色地完成了它的工作！但是 <code>fmap</code> 是咋知道如何应用函数的？<h2 id=functor-究竟是啥>Functor 究竟是啥</h2><p><code>Functor</code> 是一个 typeclass，这是它的定义：</p><img src=/images/functors/functor_def.png class=bri><p>对于任意类型，只要它定义了 <code>fmap</code> 的处理方式，它就是一个 <code>Functor</code>。下面是 <code>fmap</code> 的工作原理：</p><img src=/images/functors/fmap_def.png class=bri><p>因此我们可以：<pre><code class=language-haskell>&gt; fmap (+3) (Just 2)
Just 5
</code></pre><p>然后 <code>fmap</code> 会魔法般地，应用该函数，因为 <code>Maybe</code> 就是一个 <code>Functor</code>。它定义了 <code>fmap</code> 如何作用于 <code>Just</code>s 和 <code>Nothing</code>s：<pre><code class=language-haskell>instance Functor Maybe where
    fmap func (Just val) = Just (func val)
    fmap func Nothing = Nothing
</code></pre><p>这就是当我们写 <code>fmap (+3) (Just 2)</code> 时，幕后所发生的事：</p><img src=/images/functors/fmap_just.png class=bri><p>然后，你是不是会想，让我试试把 <code>(+3)</code> 应用到 <code>Nothing</code> 上？</p><img src=/images/functors/fmap_nothing.png class=bri><pre><code class=language-haskell>&gt; fmap (+3) Nothing
Nothing
</code></pre><img src=/images/functors/bill.png class=bri><p>像黑客帝国中的 Morpheus，<code>fmap</code> 知道要做什么；你投给它一个 <code>Nothing</code>，它也会回给你一个 <code>Nothing</code>！现在就能理解 <code>Maybe</code> 存在的意义了。下面是在一个没有 <code>Maybe</code> 的语言中，操作数据库记录的例子：<pre><code class=language-ruby>post = Post.find_by_id(1)
if post
  return post.title
else
  return nil
end
</code></pre><p>但在 Haskell，只需：<pre><code class=language-haskell>fmap (getPostTitle) (findPost 1)
</code></pre><p>如果 <code>findPost</code> 返回了一篇文章，我们将使用 <code>getPostTitle</code> 得到它的标题。同时，如果返回的是 <code>Nothing</code>，我们也仅会得到一个 <code>Nothing</code>！很整洁对吧？<code>&lt;$></code> 是 <code>fmap</code> 的中缀版本，因此你会经常看到：<pre><code class=language-haskell>getPostTitle &lt;$&gt; (findPost 1)
</code></pre><p>还有另外一个例子：当将一个函数，应用到一个列表，会发生什么？</p><img src=/images/functors/fmap_list.png class=bri><p>列表也是一个函数！这是它的定义：<pre><code class=language-haskell>instance Functor [] where
    fmap = map
</code></pre><p>好吧，最后一个例子：当将一个函数，应用到另外一个函数，会发生什么？<pre><code class=language-haskell>fmap (+3) (+1)
</code></pre><p>首先，这是一个函数：</p><img src=/images/functors/function_with_value.png class=bri><p>当我们将其应用到另一个函数时：</p><img src=/images/functors/fmap_function.png class=bri><p>结果是另一个函数：<pre><code class=language-haskell>&gt; import Control.Applicative
&gt; let foo = fmap (+3) (+2)
&gt; foo 10
15
</code></pre><p>所以说，函数也是 <code>Functor</code>！<pre><code class=language-haskell>instance Functor ((-&gt;) r) where
    fmap f g = f . g
</code></pre><p>当你在一个函数上使用 <code>fmap</code> 时，你其实是在组合它们，使其成为一个新的函数！<h2 id=applicatives>Applicatives</h2><p><code>Applicative</code> 将 <code>Functor</code> 提高了一个层次。与 <code>Functor</code> 类似，我们的值，被放在一个上下文里：</p><img src=/images/functors/value_and_context.png class=bri><p>但是，我们的函数，现在也被放在了上下文里！</p><img src=/images/functors/function_and_context.png class=bri><p>让我们慢慢理解它。<code>Control.Applicative</code> 定义了 <code>&lt;*></code>，它知道如何，为一个放在上下文里的值，应用一个放在上下文里的函数。如 <code>Just (+3) &lt;*> Just 2 == Just 5</code>：</p><img src=/images/functors/applicative_just.png class=bri><p>使用 <code>&lt;*></code> 会产生许多有趣的现象，如：<pre><code class=language-haskell>&gt; [(*2), (+3)] &lt;*&gt; [1, 2, 3]
[2, 4, 6, 4, 5, 6]
</code></pre><img src=/images/functors/applicative_list.png class=bri><p>以下是一些 <code>Applicative</code> 能做，而 <code>Functor</code> 不能做的事。如果为两个上下文里的值，应用一个接收两个参数的函数呢？<pre><code class=language-haskell>&gt; (+) &lt;$&gt; (Just 5)
Just (+5)
&gt; Just (+5) &lt;$&gt; (Just 4)
ERROR ??? WHAT DOES THIS EVEN MEAN WHY IS THE FUNCTION WRAPPED IN A JUST
</code></pre><p>使用 <code>Applicative</code>：<pre><code class=language-haskell>&gt; (+) &lt;$&gt; (Just 5)
Just (+5)
&gt; Just (+5) &lt;*&gt; (Just 3)
Just 8
</code></pre><p><code>Applicative</code> 击败了 <code>Functor</code>。“大人可以使用任意数量参数的函数，”它说。“装备了 <code>&lt;$></code> 和 <code>&lt;*></code>，我可以接受任何函数，它们接受任意数量上下文里的值。然后，我将值传入，并得到一个传出的值！哈哈哈哈！”<pre><code class=language-haskell>&gt; (*) &lt;$&gt; Just 5 &lt;*&gt; Just 3
Just 15
</code></pre><p>也可以通过 <code>liftA2</code> 达到与上面相同的效果：<pre><code class=language-haskell>&gt; liftA2 (*) (Just 5) (Just 3)
Just 15
</code></pre><h2 id=monads>Monads</h2><p>学习 Monad 的方法：<ol><li>读一个计算机科学的 PhD。<li>抛之脑后，不要想它。因为在本节你不需要它！</ol><p>Monad 添加了一个新的转变。<p><code>Functor</code> 为上下文里的值，应用一个函数：</p><img src=/images/functors/fmap.png class=bri><p><code>Applicative</code> 为上下文里的值，应用一个上下文里的函数：</p><img src=/images/functors/applicative.png class=bri><p><code>Monad</code> 为上下文里的值，应用一个接受普通值、返回上下文值的函数。它有一个 <code>>>=</code>（读作 “bind”）函数做到这点。
让我们看一个例子。我们熟悉的 <code>Maybe</code>，它也是个 Monad：</p><img src=/images/functors/context.png class=bri><p>假设 <code>half</code> 是一个仅对偶数有效的函数：<pre><code class=language-haskell>half x = if even x
           then Just (x `div` 2)
           else Nothing
</code></pre><img src=/images/functors/half.png class=bri><p>我们喂给它一个上下文里的值，会发生什么？</p><img src=/images/functors/half_ouch.png class=bri><p>我们需要用 <code>>>=</code> 将上下文里的值，推到该函数中。这是它的照片：</p><img src=/images/functors/plunger.jpg class=bri><p>它是这样运行的：<pre><code class=language-haskell>&gt; Just 3 &gt;&gt;= half
Nothing
&gt; Just 4 &gt;&gt;= half
Just 2
&gt; Nothing &gt;&gt;= half
Nothing
</code></pre><p>那么，内部到底发生了什么？<code>Monad</code> 是一个 typeclass，这是它的部分定义：<pre><code class=language-haskell>class Monad m where
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre><p>其中 <code>>>=</code> 如图所示：</p><img src=/images/functors/bind_def.png class=bri><p>所以 <code>Maybe</code> 是一个 Monad：<pre><code class=language-haskell>instance Monad Maybe where
    Nothing &gt;&gt;= func = Nothing
    Just val &gt;&gt;= func  = func val
</code></pre><p>这是它和 <code>Just 3</code> 的运作过程！</p><img src=/images/functors/monad_just.png class=bri><p>并且，当你传入一个 <code>Nothing</code>，它会更简单：</p><img src=/images/functors/monad_nothing.png class=bri><p>你还可以将它们链式调用：<pre><code class=language-haskell>&gt; Just 20 &gt;&gt;= half &gt;&gt;= half &gt;&gt;= half
Nothing
</code></pre><img src=/images/functors/monad_chain.png class=bri>
<img src=/images/functors/whoa.png class=bri><p>Cool！目前为止，我们知道 <code>Maybe</code> 是一个 Functor、一个 Applicative，还是个 Monad。
现在，让我们转向另一个例子：<code>IO</code> monad：</p><img src=/images/functors/io.png class=bri><p>具体只看三个函数。<code>getLine</code> 不接收任何参数，并获取用户的输入：</p><img src=/images/functors/getLine.png class=bri><pre><code class=language-haskell>getLine :: IO String
</code></pre><p><code>readFile</code> 接收一个 <code>string</code> 类型的文件名，并返回文件的内容：</p><img src=/images/functors/readFile.png class=bri><pre><code class=language-haskell>readFile :: FilePath -&gt; IO String
</code></pre><p><code>putStrLn</code> 接收一个 <code>string</code>，并将其打印：</p><img src=/images/functors/putStrLn.png class=bri><pre><code class=language-haskell>putStrLn :: String -&gt; IO ()
</code></pre><p>这三个函数都接收一个常规的值（或不接收），并返回上下文里的值。我们可以使用 <code>>>=</code> 将它们链起来！</p><img src=/images/functors/monad_io.png class=bri><pre><code class=language-haskell>getLine &gt;&gt;= readFile &gt;&gt;= putStrLn
</code></pre><p>好耶！前排围观 Monad 表演！
Haskell 还为我们提供了 <code>do</code>，它是 Monad 的语法糖：<pre><code class=language-haskell>foo = do
    filename &lt;- getLine
    contents &lt;- readFile filename
    putStrLn contents
</code></pre><h2 id=结论>结论</h2><ol><li>functor 是实现 <code>Functor</code> typeclass 的数据类型<li>applicative 是实现 <code>Applicative</code> typeclass 的数据类型<li>monad 是实现 <code>Monad</code> typeclass 的数据类型<li><code>Maybe</code> 实现了所有它们三个，因此是一个 functor、applicative，和 monad</ol><p>它们三个的区别是什么？</p><img src=/images/functors/recap.png class=bri><ul><li>functors：使用 <code>fmap</code> 或 <code>&lt;$></code>，为上下文里的值，应用一个函数<li>applicatives：使用 <code>&lt;*></code> 或 <code>liftA</code>，为上下文里的值，应用一个上下文里的函数<li>monads：使用 <code>>>=</code> 或 <code>liftM</code>，为上下文里的值，应用一个接受普通值、返回上下文值的函数</ul><p>所以，亲爱的朋友（我们已经算朋友了），我觉得我们都同意，monads 是一个简单、高明的想法。现在你已经对着本指南痛饮一番了，何不拉上 Mel Gibson 一醉方休呢。查看 LYAH 网站的 <a href=https://learnyouahaskell.com/a-fistful-of-monads>Monads 部分</a>。Miran 写了很多深入的，我所忽略的细节。</div><ul><li><a href=/tags/haskell>Haskell</a></ul></section></main><app></app><noscript>You need to enable JavaScript to run this app.</noscript><script type=module crossorigin src=/assets/index-b1ee8dc4.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XWVTHMXTRH"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XWVTHMXTRH")</script></body></html>