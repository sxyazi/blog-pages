<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><meta name=description content="Linux 文件系统中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有 Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。 挂载 在 linux 操作系统中， 挂载是指将一个设备（通常"><meta name=theme-color media="(prefers-color-scheme: light)" content="white"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#0f172a"><meta property="og:title" content="Linux 文件系统"><meta property="og:description" content="Linux 文件系统中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有 Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。 挂载 在 linux 操作系统中， 挂载是指将一个设备（通常"><meta property="og:type" content="article"><meta property="og:url" content="https://sxyz.blog/linux-filesystem/"><meta property="og:image" content="https://sxyz.blog/images/others/artwork.jpg"><meta property="article:section" content><meta property="article:published_time" content="2017-04-25T15:14:16+08:00"><meta property="article:modified_time" content="2017-04-25T15:14:16+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sxyz.blog/images/others/artwork.jpg"><meta name=twitter:title content="Linux 文件系统"><meta name=twitter:description content="Linux 文件系统中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有 Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。 挂载 在 linux 操作系统中， 挂载是指将一个设备（通常"><title data-site="Sxyazi’s blog">Linux 文件系统 | Sxyazi’s blog</title><link rel=stylesheet href=/assets/index-fad781fe.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><meta name=theme-color content="#ffffff"></head><body><main><nav id=nav><a href=/>Home</a><a href=/archives/>Archives</a><a href=/tags/>Tags</a><a href=/links/>Links</a><a href=/about/>About</a></nav><section id=post><h1>Linux 文件系统</h1><time datetime=2017-04-25T15:14:16+0800>04-25</time>
<span>linux-filesystem</span><div><p>Linux 文件系统中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有 Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。<h2 id=挂载>挂载</h2><p>在 linux 操作系统中， 挂载是指将一个设备（通常是存储设备）挂接到一个已存在的目录上。 我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。<p>在安装 Linux 时，会让选择系统的安装位置。比如 &ldquo;/&rdquo; ，你要把他投放到哪块硬盘哪个分区下。当系统装完了后，你在 &ldquo;/&rdquo; 下读写文件，其实就是读写的那块物理硬盘的那个分区下的数据了。此时 &ldquo;/&rdquo; 被称作挂载点。<h2 id=目录结构>目录结构</h2><p>Linux 中的目录结构是一个树状的，"/" 为最根节点，其下面的所有目录均是由 &ldquo;/&rdquo; 根目录所衍生出来的。<h2 id=文件系统>文件系统</h2><p>Linux 中使用的最普遍的文件系统是 Extended filesystem。<p>当安装完 Linux 之后，那个安装的分区就被格式化成了这种文件系统。在这种文件系统里面，每个文件是使用 inode 与 block 来承载的。<p><strong>inode</strong> 负责记录文件的属性，比如名称 大小 权限 之类的东西。还记录了 block 的号码。<p><strong>block</strong> 则是负责记录文件的数据了。<p>当我要读取某一个文件的内容的时候，那么步骤应该是：<ol><li>先从 inode 中取出文件权限，然后与你的权限对比，如果有权限进行下一步；<li>继而从 inode 中得到 block 号码，然后通过这个号码去找到对应的 block 读取数据。</ol><hr><p>再来详细说下 block。每个 block 的大小都是固定的，这个大小一般可以在格式化的时候指定的，比如这里拿 <code>4K</code> 来举例。我们说，文件数据是储存在 block 中的，但是此时我有一个 5K 的文件该怎么存？因为 block 的大小是 4K，而我们的数据要多出 1K 去，那这 1K 难道不要了？这时会再多分配出一个 <strong>4K</strong> 的 block 来存放那剩余的 1K 数据。（剩余 3K 浪费掉）<p>现在的情况是，一个 5K 的文件，使用 2 个 4K 的 block 来存储，虽然我们解决了存储 5K 文件的问题。但是这里就又有了一个新的问题。<p>在 inode 中记录的是 block 的号码，但是此时我们使用了 2 个 block 来存储的 5K 数据，那么在 inode 中记录的 block 号码，该记这 2 个 block 中的哪个呢？<p>当然是要全都记录下来，不然岂不是 5K 的文件在读取时只能得到 4K 。在 ext3 文件系统中，最多可以记录 12 个 block 号码，这里叫 <code>直接块</code> 。也就是最多可以存储 12 * 4K = <code>48K</code> 。但是这也太少了吧？这意味着在 ext3 文件系统中每个块大小设置为 4K，单文件最大容量才 48K 呢。<p>所以在这时候，可以使用 <code>一级间址</code> 的形式来记录更大文件的 block 号码，首先先在 <code>一级间址</code> 中记录 <strong>一个</strong> block 的号码，再由这一个 block 去记录整个文件的 block 的号码。因此 <code>一级间址</code> 形式最大存储文件大小是：<pre><code class=language-bash>(4K / 4Byte) * 4K = 4M   # 4Byte 是每个 block 号码占用的大小
</code></pre><p>但是这样能够储存的文件还是很小，所以就有了 <code>二级间址</code>、<code>三级间址</code> ，和 <code>一级间址</code> 的原理是一样的，具体可以参考下面的这张图：<p><img src=/images/linux-fs/addressing.jpg alt><p>还是按照 4K 的 block 大小，来计算一下单个文件最大大小是多少：<pre><code class=language-bash> ​ 12 * 4K                # 直接块(48K)
+ (4K / 4Byte) * 4K      # 一级间址(4M)
+ (4K / 4Byte) ^ 2 * 4K  # 二级间址(4G)
+ (4K / 4Byte) ^ 3 * 4K  # 三级间址(4T)
≈ 4T
</code></pre><p>虽然算出来的是 4T ，但是由于一些限制，实际达不到 4T。<hr><p>在目前最新的 <code>ext4</code> 文件系统中，支持了使用 extent 树的形式存储数据块的映射结构，这意味着可以不再使用上面的 一级间址/二级间址/三级间址 这种繁琐且效率低下的方法了。<h2 id=目录内容>目录内容</h2><p>现在已经知道了文件是如何存储的，但是目录又是怎么存储的呢？如何判定一个目录下面有哪些文件呢？<p>每个目录也对应于一个或多个 block ，而这个 block 就是记录文件名和文件的 inode 号码的关系对照表。例如下面这样：<table><thead><tr><th style=text-align:left>文件名<th>inode<tbody><tr><td style=text-align:left>a.mp4<td>100000<tr><td style=text-align:left>b.mp4<td>100001<tr><td style=text-align:left>&mldr;.<td>&mldr;.</table><p>至于目录对应多少 block ，则是由目录文件数量决定的，如果文件多所分到的 block 数也就大。<p>现在我们应该能发现了，如果要读取 <code>/a.mp4</code> ，那么要首先去读取 <code>/</code> 这个目录的 block （因为不读取的话你没法得到 <code>a.mp4</code> 这个文件的 <code>inode</code> 号码吧？）。等有了 inode 号码，再去根据 inode 对应的文件 block 读到文件内容。<p>所以，读取一个文件的步骤应该在前面再加上两条：<ol><li>得到 / 的 inode (每个目录都有自己的 inode 号码，根目录的一般是 <code>2</code> )；<li>通过 / 的 inode 得到 / 的 block；<li>从 / 的 block 中得到文件的 inode 号；<li>从 inode 中取出文件权限，然后与你的权限对比，如果有权限进行下一步；<li>最后从 inode 中得到 block 号码，然后通过这个号码去找到对应的 block 读取数据。</ol></div><ul><li><a href=/tags/linux>Linux</a></ul></section></main><app></app><noscript>You need to enable JavaScript to run this app.</noscript><script type=module crossorigin src=/assets/index-b1ee8dc4.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XWVTHMXTRH"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XWVTHMXTRH")</script></body></html>